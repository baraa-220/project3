# task0_dna.py
# Saves functions and a simple CLI that reads dna_coords.txt in the same folder.
import numpy as np
from typing import List, Tuple

def read_coords_from_dna(filename: str = "dna_coords.txt") -> List[np.ndarray]:
    """
    Read coordinates from dna_coords.txt.
    Accepts lines of form:
      x y z element
    or
      ELEMENT x y z
    Skips blank or comment lines.
    Returns list of numpy arrays [x, y, z].
    """
    coords = []
    with open(filename, 'r') as f:
        for line in f:
            s = line.strip()
            if not s or s.startswith('#'):
                continue
            parts = s.split()
            # Try formats where first three tokens are floats
            if len(parts) >= 3:
                try:
                    x = float(parts[0]); y = float(parts[1]); z = float(parts[2])
                    coords.append(np.array([x, y, z], dtype=float))
                    continue
                except ValueError:
                    pass
            # Try format: ELEMENT x y z
            if len(parts) >= 4:
                try:
                    x = float(parts[1]); y = float(parts[2]); z = float(parts[3])
                    coords.append(np.array([x, y, z], dtype=float))
                    continue
                except ValueError:
                    pass
            raise ValueError(f"Unrecognized line format: {line.rstrip()}")
    if not coords:
        raise ValueError(f"No coordinates parsed from {filename}")
    return coords

def bounding_box(coords: List[np.ndarray], padding: float = 1.0) -> Tuple[np.ndarray, np.ndarray]:
    """
    Compute axis-aligned bounding box (box_min, box_max) with padding.
    """
    arr = np.vstack(coords)
    box_min = arr.min(axis=0) - padding
    box_max = arr.max(axis=0) + padding
    if np.any(box_max <= box_min):
        raise ValueError("Computed bounding box has non-positive extent on at least one axis")
    return box_min, box_max

def box_volume(box_min: np.ndarray, box_max: np.ndarray) -> float:
    """Return box volume (units^3 matching coordinates)."""
    return float(np.prod(box_max - box_min))

def print_box_summary(box_min: np.ndarray, box_max: np.ndarray):
    dims = box_max - box_min
    vol = box_volume(box_min, box_max)
    print(f"Parsed atoms: (use read_coords_from_dna to get actual count externally)")
    print(f"box_min = ({box_min[0]:.5f}, {box_min[1]:.5f}, {box_min[2]:.5f})")
    print(f"box_max = ({box_max[0]:.5f}, {box_max[1]:.5f}, {box_max[2]:.5f})")
    print(f"dimensions (dx, dy, dz) = ({dims[0]:.5f}, {dims[1]:.5f}, {dims[2]:.5f})")
    print(f"box volume = {vol:.5f} (units^3)")

if __name__ == "__main__":
    # Run example using dna_coords.txt in same folder
    filename = "dna_coords.txt"
    padding = 1.0  # adjust to 0.5-2.0 as needed
    coords = read_coords_from_dna(filename)
    box_min, box_max = bounding_box(coords, padding=padding)
    # print count explicitly here
    print(f"Parsed atoms: {len(coords)}")
    print_box_summary(box_min, box_max)




######'


# Task 0 â€” bounding box in-notebook (paste and run)
import numpy as np
from typing import List, Tuple
import os

def read_coords_from_dna(filename: str = "dna_coords.txt") -> List[np.ndarray]:
    """
    Read coordinates from dna_coords.txt placed in the notebook working directory.
    Accepts lines of form:
      x y z element
    or
      ELEMENT x y z
    Skips blank or comment lines. Returns list of numpy arrays [x, y, z].
    """
    coords = []
    with open(filename, 'r') as f:
        for line in f:
            s = line.strip()
            if not s or s.startswith('#'):
                continue
            parts = s.split()
            # Try formats where first three tokens are floats
            if len(parts) >= 3:
                try:
                    x = float(parts[0]); y = float(parts[1]); z = float(parts[2])
                    coords.append(np.array([x, y, z], dtype=float))
                    continue
                except ValueError:
                    pass
            # Try format: ELEMENT x y z
            if len(parts) >= 4:
                try:
                    x = float(parts[1]); y = float(parts[2]); z = float(parts[3])
                    coords.append(np.array([x, y, z], dtype=float))
                    continue
                except ValueError:
                    pass
            raise ValueError(f"Unrecognized line format: {line.rstrip()}")
    if not coords:
        raise ValueError(f"No coordinates parsed from {filename}")
    return coords

def bounding_box(coords: List[np.ndarray], padding: float = 1.0) -> Tuple[np.ndarray, np.ndarray]:
    """
    Compute axis-aligned bounding box (box_min, box_max) with padding.
    """
    arr = np.vstack(coords)
    box_min = arr.min(axis=0) - padding
    box_max = arr.max(axis=0) + padding
    if np.any(box_max <= box_min):
        raise ValueError("Computed bounding box has non-positive extent on at least one axis")
    return box_min, box_max

def box_volume(box_min: np.ndarray, box_max: np.ndarray) -> float:
    """Return box volume (units^3 matching coordinates)."""
    return float(np.prod(box_max - box_min))

def print_box_summary(box_min: np.ndarray, box_max: np.ndarray, count: int):
    dims = box_max - box_min
    vol = box_volume(box_min, box_max)
    print(f"N atoms: {count}")
    print(f"box_min = ({box_min[0]:.5f}, {box_min[1]:.5f}, {box_min[2]:.5f})")
    print(f"box_max = ({box_max[0]:.5f}, {box_max[1]:.5f}, {box_max[2]:.5f})")
    print(f"dimensions (dx, dy, dz) = ({dims[0]:.5f}, {dims[1]:.5f}, {dims[2]:.5f})")
    print(f"box volume = {vol:.5f} (units^3)")

# -------------------------
# Run Task 0 in this notebook
# -------------------------
filename = "dna_coords.txt"
padding = 1.0  # adjust to 0.5-2.0 as needed

# optional quick check of working directory and file presence
print("Working directory:", os.getcwd())
print("dna_coords.txt present:", os.path.exists(filename))

coords = read_coords_from_dna(filename)
box_min, box_max = bounding_box(coords, padding=padding)
print_box_summary(box_min, box_max, len(coords))
